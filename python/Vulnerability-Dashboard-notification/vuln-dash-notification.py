import requests
import sqlite3
import json
from datetime import datetime, timedelta
import logging
from typing import Optional, Dict, Any, List
import os
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
import yaml
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import re


# Set config function
def load_config(config_path: str = "config.yaml") -> Dict[str, Any]:
    """Load configuration from a YAML file and validate required fields."""
    try:
        with open(config_path, "r", encoding="utf-8") as file:
            config = yaml.safe_load(file)

        # Define required fields
        required_fields = {
            "feedly": ["api_key", "api_config"],
            "database": ["path"],
            "slack": ["bot_token", "channel"],
            "gmail": ["sender_email", "sender_password", "recipient_email"]
        }

        # Validate required sections and keys
        for section, keys in required_fields.items():
            if section not in config:
                raise ValueError(f"Missing required section '{section}' in config.yaml")
            for key in keys:
                if key not in config[section]:
                    raise ValueError(f"Missing key '{key}' under '{section}' in config.yaml")

        return config

    except FileNotFoundError:
        print("Error: Configuration file not found.")
        raise
    except yaml.YAMLError as e:
        print(f"Error parsing YAML configuration: {e}")
        raise
    except ValueError as ve:
        print(f"Configuration Error: {ve}")
        raise


# Validate and create Database
class VulnerabilityTracker:
    def __init__(self, config: Dict[str, Any]):
        """Initialize the tracker with configuration settings."""
        self.db_path = config["database"]["path"]  # Database path from config

        self.api_key = config["feedly"]["api_key"]  # Feedly API Key
        self.api_config = config["feedly"]["api_config"]  # Feedly API query configuration

        self.slack_bot_token = config["slack"]["bot_token"]  # Slack Bot Token
        self.slack_channel = config["slack"]["channel"]  # Slack Channel ID
        self.slack_client = WebClient(token=self.slack_bot_token)  # Initialize Slack client

        # Teams webhook URL (optional)
        self.teams_webhook_url = config.get("teams", {}).get("webhook_url")

        self.base_url = "https://api.feedly.com/v3/trends/vulnerability-dashboard"  # Correct Feedly API URL
        self.current_run_time = datetime.utcnow()  # Store script execution time
        self.config = config  # Store full configuration

        self.setup_logging()  # Set up logging
        self.init_database()  # Initialize database

    # Set up logging messages
    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s"
        )
        self.logger = logging.getLogger(__name__)

    # Initialise the database storing vulnerabilities from Vuln Dash
    def init_database(self):
        db_exists = os.path.exists(self.db_path)
        os.makedirs(os.path.dirname(os.path.abspath(self.db_path)),exist_ok=True)
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("PRAGMA foreign_keys = ON")

            conn.execute('''
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id TEXT PRIMARY KEY,
                    cveid TEXT,
                    cvss REAL,
                    data JSON,
                    hash TEXT,
                    last_updated TIMESTAMP
                )
            ''')

            conn.execute('''
                CREATE TABLE IF NOT EXISTS change_log (
                    id TEXT,
                    changed_at TEXT,
                    field_name TEXT,
                    old_value TEXT,
                    new_value TEXT,
                    change_type TEXT,
                    FOREIGN KEY (id) REFERENCES vulnerabilities (id)
                )
            ''')

            conn.execute('''
                CREATE TABLE IF NOT EXISTS script_metadata (
                    key TEXT PRIMARY KEY,
                    value TEXT
                )
            ''')

        if not db_exists:
            self.logger.info(f"created new database at {self.db_path}")
        else:
            self.logger.info(f"Connected to existing database at {self.db_path}")

    def fetch_vulnerabilities(self) -> Dict[str, Any]:
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type" : "application/json"
        }

        try:
            response = requests.post(self.base_url, json=self.api_config, headers=headers)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            self.logger.error(f"API request failed {str(e)}")
            return {}

    def process_vulnerabilities(self):
        # Fetch vulnerabilities and detect change
        vulnerabilities = self.fetch_vulnerabilities().get('vulnerabilities',[])

        if not vulnerabilities:
            self.logger.info("No new vulnerabilities found.")
            return

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        notifications = []

        for vuln in vulnerabilities:
            vuln_id = vuln["id"]
            cve_id = vuln.get("cveid", "unknown CVE")
            cvss_score = vuln.get("cvssV3", {}).get("baseScore","N/A")
            vuln_ic = "https://feedly.com/i/cve/" + cve_id

            affected_products = vuln.get("affectedProductsEstimate",[])
            if affected_products:
                vendor = affected_products[0].get("vendor", "N/A")
                product = [p["name"] for p in affected_products[0].get("products",[])]
            else:
                vendor = 'N/A'
                product = []

            vuln_data = json.dumps(vuln)
            cursor.execute("SELECT data FROM vulnerabilities WHERE id = ?", (vuln_id,))
            result = cursor.fetchone()

            if result:
                old_data = json.loads(result[0])
                if old_data != vuln:
                    cursor.execute('''
                        UPDATE vulnerabilities
                        SET data = ?, last_updated = ?, cvss = ?
                        WHERE id = ?
                    ''', (vuln_data, self.current_run_time.isoformat(), cvss_score, vuln_id))

                    self.logger.info(f"Updated vulnerability: {cve_id}")
                    self.send_slack_notification(cve_id, "updated", vuln, vuln_ic)
                    self.send_teams_notification(cve_id, "updated", vuln, vuln_ic)
                    notifications.append((cve_id, "updated", vuln, vuln_ic))

            else:
                cursor.execute('''
                    INSERT INTO vulnerabilities (id, cveid, data, last_updated, cvss) VALUES (?,?,?,?,?)
                ''', (vuln_id, cve_id, vuln_data, self.current_run_time.isoformat(), cvss_score))

                self.logger.info(f"New vulnerability found: {cve_id}")
                self.send_slack_notification(cve_id, "new", vuln, vuln_ic)
                self.send_teams_notification(cve_id, "new", vuln, vuln_ic)
                notifications.append((cve_id, "new",vuln,vuln_ic))

        conn.commit()
        conn.close()
        if notifications:
            self.send_email_notification(notifications)

    def send_slack_notification(self, cve_id: str, change_type:str, vuln_data: Dict[str,Any], insight_url: str):
        # Send a notification to slack when a new or updated vulnerability is found
        cvss_score = vuln_data.get("cvssV3", {}).get("baseScore", "N/A")
        affected_products = vuln_data.get("affectedProductsEstimate")
        message = (
            f"*{change_type.upper()} CVE Alert*\n"
            f"> *CVE ID:* {cve_id}\n"
            f"> *CVSS Score:*{cvss_score}\n"
            f"> *Check full Insight Card* <{insight_url} | in Feedly>\n"
            f"> *Affected product:* {affected_products}"
        )

        try:
            response = self.slack_client.chat_postMessage(
                channel=self.slack_channel,
                text=message,
                parse="mrkdwn"
            )
            if response["ok"]:
                self.logger.info(f"Sent Slack notification for {cve_id}")
            else:
                self.logger.error(f"Failed to send Slack message: {response['error']}")

        except SlackApiError as e:
            self.logger.error(f"Slack API Error: {str(e)}")

    def send_teams_notification(self, cve_id: str, change_type: str, vuln_data: Dict[str, Any], insight_url: str):
        """Send a notification to Microsoft Teams when a new or updated vulnerability is found."""
        if not self.teams_webhook_url:
            return

        cvss_score = vuln_data.get("cvssV3", {}).get("baseScore", "N/A")
        affected_products = vuln_data.get("affectedProductsEstimate")

        # Create Teams-formatted message
        message = (
            f"**{change_type.upper()} CVE Alert**\n"
            f"• **CVE ID:** {cve_id}\n"
            f"• **CVSS Score:** {cvss_score}\n"
            f"• **Check full Insight Card:** [in Feedly]({insight_url})\n"
            f"• **Affected product:** {affected_products}"
        )

        self.send_teams_message(message)

    def send_teams_message(self, message: str) -> None:
        """Send a message to Microsoft Teams via webhook."""
        if not self.teams_webhook_url:
            return
        try:
            # Convert Slack's *<url|text>* format to Teams' **[text](url)** format
            teams_message = message
            # Find all Slack-style links: *<url|text>*
            slack_links = re.findall(r'\*<([^|]+)\|([^>]+)>\*', teams_message)
            # Replace each link with Teams markdown format
            for url, text in slack_links:
                slack_format = f'*<{url}|{text}>*'
                teams_format = f'**[{text}]({url})**'
                teams_message = teams_message.replace(slack_format, teams_format)

            # Format the message with appropriate newlines
            # Add newline after CVE ID and field name
            teams_message = re.sub(r'(\*\*\[.*?\]\(.*?\)\*\*) - ([^:]+):', r'\1\n\2:', teams_message)
            # Ensure bullet points start on new lines and are properly spaced
            teams_message = re.sub(r'([^:\n])(•)', r'\1\n•', teams_message)
            teams_message = re.sub(r'(\n•[^\n]+)(\n•)', r'\1\n\2', teams_message)

            # Split message into parts if it's too long
            header = teams_message.split("\n\n")[0]  # Keep the header
            updates = teams_message.split("\n\n")[1:]  # Get all updates

            # Send updates in batches
            batch_size = 40  # Increased batch size
            for i in range(0, len(updates), batch_size):
                batch = updates[i:i + batch_size]
                batch_message = f"{header}\n\n" + "\n\n".join(batch)

                payload = {
                    "text": batch_message
                }

                response = requests.post(
                    self.teams_webhook_url,
                    json=payload,
                    headers={"Content-Type": "application/json"}
                )
                response.raise_for_status()
                self.logger.info(f"Successfully sent Teams message batch {i//batch_size + 1}")

        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error sending message to Teams: {str(e)}")

    def send_email_notification(self, notifications: List[tuple]):
        sender = self.config["gmail"]["sender_email"]
        password = self.config["gmail"]["sender_password"]
        recipient = self.config["gmail"]["recipient_email"]
        subject = f"CVE Digest: {len(notifications)} new/updated vulnerabilities"

        body = ""
        for cve_id, change_type, vuln_data, insight_url in notifications:
            cvss_score = vuln_data.get("cvssV3", {}).get("baseScore", "N/A")
            description = vuln_data.get("description", "No description available.")
            affected = vuln_data.get("affectedProductEstimate", [])
            if affected:
                vendor = affected[0].get("vendor","N/A")
                products = [p["name"] for p in affected[0].get("products",[])]
            else:
                vendor = "N/A"
                products = []

            body += f"""
    <h2>{change_type.upper()} CVE Alert</h2>
    <p><strong>CVE ID:</strong> {cve_id}</p>
    <p><strong>CVSS Score:</strong> {cvss_score}</p>
    <p><strong>Vendor:</strong> {vendor}</p>
    <p><strong>Products:</strong> {','.join(products)}</p>
    <p><strong>Description:</strong> {description}</p>
    <p><strong>Insight Cards:</strong><a href='{insight_url}'>{insight_url}</a></p>
    -------------------------------------------------------------
    """

        message = MIMEMultipart()
        message["From"] = sender
        message["To"] = recipient
        message['Subject'] = subject
        message.attach(MIMEText(body,"html"))

        try:
            with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
                server.login(sender, password)
                server.send_message(message)
                self.logger.info("Sent email digest")
        except Exception as e:
            self.logger.error(f"Failed to send email digest: {str(e)}")


def main():
    try:
        config = load_config()
        tracker = VulnerabilityTracker(config)
        tracker.logger.info("Vulnerability tracker initialised successfully")
        tracker.process_vulnerabilities()
    except Exception as e:
        logging.error(f"Error initialising vulnerability tracker: {str(e)}")
        raise


if __name__ == "__main__":
    main()
